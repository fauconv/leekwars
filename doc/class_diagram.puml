@startuml

abstract class Action {
  void execute()
}
class SetWeaponAction {
  -integer toolId
  +constructor(integer toolId)
  +execute()
}
class MoveAction {
  -integer cellId
  +constructor(integer cellId)
  +execute()
}
class ToolAction {
  -integer toolId
  -integer targetCell
  +constructor(integer toolId, integer targetCell)
  +execute()
}
entity Board {
  {static} +integer myId
  {static} +integer maxAOERange
  {static} +Me me
  {static} +RealRound currentRound
  {static} +RealRound previousRound
  {static} +Cell centerCell
  {static} +boolean init()
  {static} +void update()
}
abstract class Cell {
  +integer x
  +integer y
  +boolean isDeadEnd
  +boolean isWall
  +Cell top
  +Cell bottom
  +Cell left
  +Cell right
  +Cell leftTop
  +Cell rightTop
  +Cell leftBottom
  +Cell rightBottom
  #constructor(integer idCell, InterCellInfo interCellNull)
}
class FreeCell {
  +constructor(integer idCell, InterCellInfo interCellNull)
  +Array<Integer> getTrajectory(FreeCell endCell)
  +Map<integer,RelativeCell> getRelativeCells(Array<Tool> tools)???
}
class Wall {
  constructor(integer idCell, InterCellInfo interCellNull)
}
class InterCellInfo {
  +integer range
  +boolean isInline
  +boolean isDiag
  constructor()
  constructor(Cell cellFrom, Cell cellTo)
}
class CellRound {
  +Cell cell
  +LeekRound leekOnCell
  +Round roundObj
  +constructor(Round roundObj, Cell cell)
}
class Effect {
  +string category
  +Enumeration type
  +integer minEffect
  +integer maxEffect
  +integer midEffect
  +integer turns
  +boolean targetAllie
  +boolean targetCaster
  +boolean targetSummon
  +boolean targetNonSummon
  +boolean targetEnemy
  +boolean modIred
  +boolean modMulti
  +boolean modNoRep
  +boolean modOnCast
  +boolean modStack
  +Tool owner
  +Function<Effect, LeekRound, LeekRound => EffectResult> simulateUseFunction???
  +real tmpMidCriticalLuck???
  +real tmpMinEffect???
  +real tmpMaxEffect???
  +real tmpMidEffect???
  constructor(Array<integer|real> effectArray, Tool owner)
}
class EffectResult
abstract class LeekRound {
  +Leek leek
  +CellRound currentCell
  +integer currentCellId
  +integer minTP
  +integer maxTP
  +integer midTP
  +integer maxTotalLife
  +integer minTotalLife
  +integer midTotalLife
  +integer maxLife
  +integer midLife
  +integer minLife
  +integer minResistance
  +integer maxResistance
  +integer midResistance
  +integer minAgility
  +integer maxAgility
  +integer midAgility
  +integer minStrength
  +integer maxStrength
  +integer midStrength
  +integer minMagic
  +integer maxMagic
  +integer midMagic
  +integer minScience
  +integer maxScience
  +integer midScience
  +integer minWisdom
  +integer maxWisdom
  +integer midWisdom
  +integer minAbsoluteShield
  +integer maxAbsoluteShield
  +integer midAbsoluteShield
  +integer minRelativeShield
  +integer maxRelativeShield
  +integer midRelativeShield
  +integer minDmgReturn
  +integer maxDmgReturn
  +integer midDmgReturn
  +integer minMP
  +integer maxMP
  +integer midMP
  +integer minPower
  +integer maxPower
  +integer midPower
  +integer maxInjury
  +integer midInjury
  +integer minInjury
  +integer maxAOERange
  +ToolRound weapon
  +integer weaponId
  +Round roundObj
  +Map<integer,Array<Array<integer|boolean>>> effects
  #constructor(Round roundObj, Leek|LeekRound leek)
  +void update()
  -void categoriseTool(ToolRound toolRound)
  +Map<integer,integer> route(integer remainingMP)
  +EffectResult addToolAction(integer toolId, integer targetCellId)
  +void addMoveAction(integer cellId, integer usedMP)
  +void addSetWeaponAction(integer weaponId)
  +void execute()
}
abstract class ToolRound {
 +Tool tool
 +integer cooldown
 +Round roundObj
 +LeekRound owner
 #constructor(Tool|ToolRound tool, LeekRound owner)
 +EffectResult simulateUseOnCell(integer cellId)
 #EffectResult simulateUse(Array<Integer> targets,integer cellId)
 +void useOnCell(integer cellId)
}
class WeaponRound {
 +constructor(Tool|ToolRound tool, LeekRound owner)
 +void useOnCell(integer cellId)
 +EffectResult simulateUseOnCell(integer cellId)
}
class ChipRound {
 +constructor(Tool|ToolRound tool, LeekRound owner)
 +void useOnCell(integer cellId)
 +EffectResult simulateUseOnCell(integer cellId)
}
class MeRound {
 +integer relativeCenterCellId
 +Array<integer>|null pathToCenter
 +constructor(Round roundObj, MeRound|null clone = null)
 +integer getRelativeCenter()
 +void execute()
}
class AllieRound {
  +constructor(Round roundObj, Leek|AllieRound leek)
}
class EnemyRound {
  +string state
  +constructor(Round roundObj, EnemyRound|Leek leek)
  +void updateState(EnemyRound previousEnemyRound, Array<InterCellInfo> myInter)
}
class RelativeCell
abstract class Tool
class Weapon
class Chip
abstract class Round {
  +MeRound MeRound
  +updateState(Round previousRound)
}
class RealRound {
  +constructor()
  +update()
}
class SimulatedRound {
  +constructor(Round clone)
}
abstract class Leek
class Me
class Enemy
class Allie

Action <|-- SetWeaponAction
Action <|-- MoveAction
Action <|-- ToolAction
Cell *-- InterCellInfo : interCellInfo
Cell <|-- FreeCell
Cell <|-- Wall
Board *-- Cell : cells
Board o-- Enemy : enemies
Board o-- Allie : allies
Board *-- Leek : leeks
Round <|-- RealRound
Round <|-- SimulatedRound
Leek <|-- Me
Leek <|-- Enemy
Leek <|-- Allie
Tool <|-- Weapon
Tool <|-- Chip
LeekRound <|-- MeRound
LeekRound <|-- AllieRound
LeekRound <|-- EnemyRound
Round *-- CellRound : cellsRound
Round o-- AllieRound : alliesRound
Round o-- EnemyRound : enemiesRound
Round *-- LeekRound : leeksRound
LeekRound *-- ToolRound : toolsRound
LeekRound o-- WeaponRound : weaponsRound
LeekRound o-- ChipRound : chipsRound
ToolRound <|-- WeaponRound
ToolRound <|-- ChipRound
LeekRound o-- Action : actions

@enduml
