include("objects");

/*****************************************************************************
 * GameDebug
 *****************************************************************************/
class GameDebug {
  
  static string str = "\n";
  static integer opt = 0;
  static integer ram = 0;
 
  /**
   * str
   **/
  static void display() {
    addOperation(true, "( "+getTP()+" TP / "+getMP()+" MP left ) total operations, turn "+getTurn());
    debug(str);
    str = "\n";
    opt = 0;
    ram = 0;
  }
  
  /***
   * arrayDebug
   *
   * internal
   **/
  private static void arrayDebug(Array<any>|Map<any,any> array, integer depth, Array<integer> limit, Array<integer> start, Array<boolean> revers, string space, string debugFunction) {
    integer lim = 1000;
    integer star = 0;
    integer cnt = 0;
    integer cpt;
    boolean rev = false;
    Array<any>|Map<any,any> tab = array;
    if(count(limit) > 0) lim = shift(limit) as integer;
    if(count(start) > 0) star = shift(start) as integer;
    if(count(revers) > 0) rev = shift(revers) as boolean;
    if(typeOf(array) == TYPE_ARRAY) {
    cpt = count(array as Array<any>);
    if(rev) reverse(tab as Array<any>);
      str += "Array("+star+"-"+lim+"/"+cpt+") [";
    } else {
      cpt = mapSize(array as Map<any,any>);
      str += "Map("+star+"-"+lim+"/"+cpt+") [";
    }
    if(cpt != 0 && depth > 0) {
      str += "\n"
      string space2 = space + "  ";
      depth--;
      for(integer key:any value in tab) {
        if(cnt >= lim) break;
        if(cnt < star) {
          cnt++;
          continue;
        }
        str += space2+key+": ";
        add(true, value, "", depth, limit, start, revers, space2, debugFunction); // ret2 pour bug de compil
        cnt++;
      }
      str += space+"]";
    } else {
      str += "]";
    }
    unshift(revers,rev);
    unshift(limit,lim);
    unshift(start, star);
  }
  
  /***
   * objectDebug
   * @param obj : TYPE_OBJECT => Object ou Objects
   * internal
   **/
  private static void objectDebug(Object|Objects obj, integer depth, Array<integer> limit, Array<integer> start, Array<boolean> revers, string space, string debugFunction) {
    string ret;
    if(depth == 0) {
      if(obj instanceof Object) {
        str += "Object";
        return;
	  }
      if(obj instanceof Objects) {
		if(debugFunction == "shortString") str += (obj as Objects).shortString();
      	else str += (obj as Objects).string();
		return;
	  }
	  str += obj.class.name + ": not herite from Objects";
      return;  
    }
    Array<string> keys;
    if(obj instanceof Object) {
	  str += "Object {";
	  keys = (obj as Object).keys();
	} else {
	  str += obj.class.name + " {";
      keys = obj.class.fields;
	}
    integer cpt = count(keys);
    if(cpt != 0) {
      str += "\n"
      string space2 = space + "  ";
      depth--;
      for(any value in keys) {
        str += space2+value+": ";
        add(true, obj[value], "", depth, limit, start, revers, space2, debugFunction);
      }
      str += space+"}";
    } else {
      str += "}";
    }
  }
  
  /**
   * add
   *
   * ajoute un element a debugger dans la liste a afficher
   **/
  static void add(boolean condition, any element, string txt = "", integer depth = 1, Array<integer> limit = [], Array<integer> start = [], Array<boolean> revers = [], string space = "", string debugFunction = "shortString") {
    if(!condition) return;
    if(txt != "") str+= txt +" => ";
    integer type = typeOf(element);
    if(type == TYPE_ARRAY || type == TYPE_MAP) {
      arrayDebug(element as Array<any>|Map<any,any>, depth, limit, start, revers, space, debugFunction);
    } else if(type == TYPE_OBJECT) {
      objectDebug(element as Object|Objects, depth, limit, start, revers, space, debugFunction);
    } else {
      str += element;
    }
    str += "\n";
  }
  
  /**
   * addBackground
   *
   * change la couleur de fond d une liste de cells ou d'un cellId
   **/
  static void addBackground(boolean condition, any cellsOrCellId, integer color = 0) {
    if(!condition) return;
    integer type = typeOf(cellsOrCellId);
    if(type == TYPE_ARRAY || type == TYPE_MAP) {
      for(any cell in cellsOrCellId as Array<any>|Map<any,any>) {
        type = typeOf(cell);
        break;
      }
      if(type == TYPE_OBJECT) {
        for(any cell in cellsOrCellId as Array<Cell|CellRound>|Map<any,Cell|CellRound>) {
          mark(cell.id, color, 1);
        }
      } else {
        for(integer cell in cellsOrCellId  as Array<integer>|Map<any,integer>) {
          mark(cell, color, 1);
        }
      }
    } else if(type == TYPE_OBJECT) {
      mark((cellsOrCellId as Objects).id, color, 1);
    } else mark(cellsOrCellId as integer, color,1);
  }
  
  /**
   * addOperation
   * calcul les opt et la ram depuis le dernier addOperation et l affiche
   **/
  static void addOperation(boolean condition, string txt = "") {
    if(!condition) return;
    integer opt2 = getOperations()-opt;
    integer ram2 = getUsedRAM()-ram;
    str += txt+" : "+opt2+"("+(opt2*100.0/OPERATIONS_LIMIT)+"%Ops) / "+ram2+"("+(ram2*100.0/getMaxRAM())+"%RAM)\n";
    opt = getOperations();
    ram = getUsedRAM();
  }
  
}



