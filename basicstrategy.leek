/****************************************************************************
 * BasicStrategy
 ****************************************************************************/
class BasicStrategy extends Strategy {
  
  static Enemy enemy;          
  static integer enemyId;
  static MeRound meRound;       // MeRound
  static EnemyRound enemyRound;    // EnemyRound
  static Round currentRound;  // Round
  
  /**
   * isValide
   *
   * refuse les match avec AOE, en groupe, ou avec bulb
   **/
  static boolean isValide() {
    if(count(Board.enemies) > 1) return false;
    enemy = Board.enemies[0];
    enemyId = enemy.id;
    return isEmpty(enemy.categoryBulb);
  }
  
  /**
   * apply
   **/
  void apply() {
    
    currentRound = Board.currentRound;
    meRound = currentRound.meRound;
    enemyRound = currentRound.enemiesRound[0];
    
    if(gFirstRound) {
      moveTowardCell(meRound.getRelativeCenter().id);
      GameDebug.addBackground(BASIC_STRATEGY_DEBUG, meRound.relativeCenterCellId, COLOR_GREEN);
      setWeapon(Board.me.weapons[0].id)
    }
  }
  

}

/**
1) determiner a quel distance ce tenir de l ennemie (premier tour seulement):
 - determiner la meilleur combo d'arme pour chaque distance
 - faire tirer chacune de mes armes et chacune de ses armes une fois et calculer la difference par range:



for (var t in enemyTools) {
  t.simulateShoot(myleek)
  for(var range = t.minRange; range <= t.maxRange; range++) {
    if(myLeek.injury > myInjury[range]) myInjury[range] = myLeek.injury;
  }
}

for (var t in myTools) {
  t.simulateShoot(enemyleek)
  for(var range = t.minRange; range <= t.maxRange; range++) {
    if(enemyLeek.injury > enemyInjury[range]) enemyInjury[range] = enemyLeek.injury;
  }
}

for (var i = 1; i < maxAOERange; i++) {
  enemyInjury[i] -= myInjury[i];
}

var gminRange = 1;
#tag1
while (enemyInjury[gminRange] < 0 && gminRange < maxAOERange) {
  gminRange++;
}
if(gminRange == maxAOERange) say("c est la merde, il est meilleure que moi a toutes les distance")
else {
  var gmaxRange = gminRange;
  while (enemyInjury[gmaxRange] > 0 && gmaxRange < maxAOERange) {
    gmaxRange++;
  }
  say("je suis meilleur que lui entre "+ gminRange+" et "+gmaxRange);
  if(gmaxRange < maxAOERange) goto "#tag1"
}

2) faire la map des degat

if("j ai une case ou je suis meilleur") {
  me.shoot()
}
if("je peux me mettre hors d attinte") {
  me.move("hors d attinte");
  me.buff()
  me.heal() 
} else {
  me.move(centerCell + minRange < (me.position - enemy.position) + me.MP < maxRange)
  if("je peux tirer") me.shoot()
  me.buff()
  me.protect()
  me.heal()
}

**/
