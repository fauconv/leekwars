include("toolround");

/******************************************************************************
 * LeekRound
 ******************************************************************************/
class LeekRound extends Objects {
  
  Leek leek;
  MoveCell currentCell;
  integer currentCellId;
  
  integer minTP;
  integer maxTP;
  integer midTP;
  integer maxTotalLife;
  integer minTotalLife;
  integer midTotalLife;
  integer maxLife;
  integer midLife;
  integer minLife;
  integer minResistance;
  integer maxResistance;
  integer midResistance;
  integer minAgility;
  integer maxAgility;
  integer midAgility;
  integer minStrength;
  integer maxStrength;
  integer midStrength;
  integer minMagic;
  integer maxMagic;
  integer midMagic;
  integer minScience;
  integer maxScience;
  integer midScience;
  integer minWisdom;
  integer maxWisdom;
  integer midWisdom;
  integer minAbsoluteShield;
  integer maxAbsoluteShield;
  integer midAbsoluteShield;
  integer minRelativeShield;
  integer maxRelativeShield;
  integer midRelativeShield;
  integer minDmgReturn;
  integer maxDmgReturn;
  integer midDmgReturn;
  integer minMP;
  integer maxMP;
  integer midMP;
  integer minPower;
  integer maxPower;
  integer midPower;

  integer maxInjury;
  integer midInjury;
  integer minInjury;
  
  integer maxAOERange;
  ToolRound|null weapon;
  integer|null weaponId;
  
  Map<integer,Array<Array<integer|boolean>>> effects = [:];
  
  Map<integer, MoveCell> moveCells = [:];
  Map<integer, ToolRound> toolsRound = [:];
  Array<WeaponRound> weaponsRound = [];
  Array<ChipRound> chipsRound = [];
  Round roundObj;
    
  Array<ToolRound> categoryDamage = [];
  Array<ToolRound> categoryProtection = [];
  Array<ToolRound> categoryHeal = [];
  Array<ToolRound> categoryMPBuff = [];
  Array<ToolRound> categoryBuff = [];
  Array<ToolRound> categoryDeBuff = [];
  Array<ToolRound> categoryBulb = []; 
  Array<ToolRound> categoryOther = [];
  Array<ToolRound> categoryMove = [];
  
  /**
   * constructor
   **/
  constructor(Leek leek, Round roundObj) {
    
      id = leek.id; 
      this.leek = leek;
      this.roundObj = roundObj;

      minTP = maxTP = midTP = getTP(id)!;
      maxTotalLife = minTotalLife = midTotalLife = getTotalLife(id)!;
      maxLife = midLife = minLife = getLife(id)!;
      minResistance = maxResistance = midResistance = getResistance(id)!;
      minAgility = maxAgility = midAgility = getAgility(id)!;
      minStrength = maxStrength = midStrength = getStrength(id)!;
      minMagic = maxMagic = midMagic = getMagic(id)!;
      minScience = maxScience = midScience = getScience(id)!;
      minWisdom = maxWisdom = midWisdom = getWisdom(id)!;
      minAbsoluteShield = maxAbsoluteShield = midAbsoluteShield = getAbsoluteShield(id)!;
      minRelativeShield = maxRelativeShield = midRelativeShield = getRelativeShield(id)!;
      minDmgReturn = maxDmgReturn = midDmgReturn = getDamageReturn(id)!;
      minMP = maxMP = midMP = getMP(id)!;
      minPower = maxPower = midPower = getPower(id)!;

      maxInjury = midInjury = minInjury = 0;

      currentCellId = getCell(id)!;
      CellRound cellRound = roundObj.cellsRound[currentCellId];
      cellRound.leekOnCell = this;
      currentCell = new MoveCell(cellRound, this, minMP);

      for(Tool tool in leek.tools) {
        if(tool.isChip) {
          if(getCooldown(tool.id) == 0) {
            ChipRound c = new ChipRound(tool, this);
            categoriseTool(c);
            push(chipsRound, c);
          }
        } else {
          WeaponRound w = new WeaponRound(tool, this);
          categoriseTool(w);
          push(weaponsRound, w);
        }
      }

      if(weaponId = getWeapon(id)) weapon = toolsRound[weaponId!];

      Array<Array<integer | boolean>> effects = getEffects(id)!;
      for(Array<integer | boolean> effect in effects) {
        if (mapContainsKey(this.effects,effect[0])) {
          push(this.effects[effect[0] as integer]!, effect);
        } else {
          this.effects[effect[0] as integer] = [effect];
        }
      }
    
  }
  
   /**
   * categoriseTool
   **/
  categoriseTool(ToolRound toolRound) {
    toolsRound[toolRound.id] = toolRound;
    Tool tool = toolRound.tool;
    for(string category in tool.categories) push(this[category] as Array<ToolRound>, toolRound);
    (tool.categories["categoryDamage"]) and
      (tool.maxAOERange > maxAOERange) and (maxAOERange = tool.maxAOERange);
  }
  
  
  /**
   * simulateSetWeaponRound
   **/
  simulateSetWeaponRound(WeaponRound weapon) {
    minTP--;
    maxTP--;
    midTP--;
    weaponId = weapon.id;
    this.weapon = weapon;
  }
  
}

/******************************************************************************
 * AllieRound
 ******************************************************************************/
class AllieRound extends LeekRound {
  
  /**
   * constructor
   **/
  constructor(Leek leek, Round roundObj) {
    super(leek, roundObj);
  }
  
}

/******************************************************************************
 * EnemyRound
 ******************************************************************************/
class EnemyRound extends LeekRound {
  
  /**
   * constructor
   **/
  constructor(Leek leek, Round roundObj) {
    super(leek, roundObj);
  }
 
}

/******************************************************************************
 * MeRound
 ******************************************************************************/
class MeRound extends LeekRound {
  
  integer relativeCenterCellId;
  CellRound|null relativeCenterCellRound;
  Cell|null relativeCenterCell;
  Array<integer>|null pathToCenter;
  
  /**
   * constructor
   **/
  constructor(Round roundObj) {
    super(Board.me, roundObj);
  }
  
  /**
   * setRelativeCenter
   *
   * @return CellRound
   **/
  CellRound getRelativeCenter() {
    if(relativeCenterCellRound != null) return relativeCenterCellRound!;
    if(!Board.centerCell.isDeadEnd) pathToCenter = getPath(currentCellId, CENTER_CELL_ID)
    if (pathToCenter) {
      relativeCenterCellId    = CENTER_CELL_ID;
      relativeCenterCell      = Board.cells[relativeCenterCellId];
      relativeCenterCellRound = roundObj.cellsRound[relativeCenterCellId];
    } else {
      Array<Cell> trajectoryToCenter = currentCell.cell.getTrajectory(Board.centerCell)
      pop(trajectoryToCenter) // remove center cell 306
      boolean ok = false;
      Cell finalCell;
      while(!isEmpty(trajectoryToCenter)) {
        finalCell = pop(trajectoryToCenter) as Cell;
        if(!finalCell.isDeadEnd) {
          if (pathToCenter = getPath(currentCellId, finalCell.id)) {
            ok = true;
            break;
          }
        }
      }
      if(ok) {
        relativeCenterCellId    = finalCell.id;
        relativeCenterCell      = finalCell;
        relativeCenterCellRound = roundObj.cellsRound[relativeCenterCellId];
      } // else relativeCenterCell = null
    }
    return relativeCenterCellRound!;
  }
  
  /**
   * setWeaponRound
   **/
  boolean setWeaponRound(WeaponRound weapon) {
    if(setWeapon(weapon.id)) {
      minTP = maxTP = midTP = getTP(id)!;
      weaponId = weapon.id;
      this.weapon = weapon;
      return true;
    }
    return false;
  }
  
}
