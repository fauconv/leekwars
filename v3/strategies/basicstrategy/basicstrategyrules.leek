include("simulation");

/**
 * condition d utilisation des chips lors de la phase de prediction des mouvements
 * 1- CHIP_STRETCHING
 * 2- CHIP_MOTIVATION
 * 3- CHIP_LEATHER_BOOTS
 * TODO: chip de saut
 **/
function MPConditions(LeekRound owner) => Array<Simulation> {
  Simulation sim2, sim3, sim = new Simulation(owner.roundObj);
  integer leekId = owner.id;
  integer currentCellId = owner.currentCellId;
  Map<integer,ToolRound> toolsRound = owner.toolsRound;
  //------------------------------------------------------------------------------------
  Array<Simulation> ret = [sim]; // cas ou on ne fait rien
  if(mapContainsKey(toolsRound, CHIP_STRETCHING)) { 
	sim2 = MPConditionsAddSim(ret, sim, leekId, CHIP_STRETCHING, currentCellId); // cas CHIP_STRETCHING
	if(mapContainsKey(toolsRound, CHIP_MOTIVATION)) { 
	  sim3 = MPConditionsAddSim(ret, sim2, leekId, CHIP_MOTIVATION, currentCellId); // cas CHIP_STRETCHING + CHIP_MOTIVATION
	  if(mapContainsKey(toolsRound, CHIP_LEATHER_BOOTS)) { 
	    MPConditionsAddSim(ret, sim3, leekId, CHIP_LEATHER_BOOTS, currentCellId); // cas CHIP_STRETCHING + CHIP_MOTIVATION + CHIP_LEATHER_BOOTS
	  }
    };
    if(mapContainsKey(toolsRound, CHIP_LEATHER_BOOTS)) { 
	  MPConditionsAddSim(ret, sim2, leekId, CHIP_LEATHER_BOOTS, currentCellId); // cas CHIP_STRETCHING + CHIP_LEATHER_BOOTS
	}
  }
  if(mapContainsKey(toolsRound, CHIP_MOTIVATION)) { 
	sim2 = MPConditionsAddSim(ret, sim, leekId, CHIP_MOTIVATION, currentCellId); // CHIP_MOTIVATION
	if(mapContainsKey(toolsRound, CHIP_LEATHER_BOOTS)) { 
	  MPConditionsAddSim(ret, sim2, leekId, CHIP_LEATHER_BOOTS, currentCellId); // CHIP_MOTIVATION + CHIP_LEATHER_BOOTS	
	}
  }
  if(mapContainsKey(toolsRound, CHIP_LEATHER_BOOTS)) { 
	MPConditionsAddSim(ret, sim, leekId, CHIP_LEATHER_BOOTS, currentCellId); // cas CHIP_LEATHER_BOOTS
  }
  return ret;
  //--------------------------------------------------------------------------------------------------
}

/**
 * MPConditionsAddSim
 * macro pour MPConditions 
 **/
function MPConditionsAddSim(Array<Simulation> ret, Simulation sim, integer leekId, integer toolId, integer currentCellId) => Simulation {
  sim = new Simulation(sim);
  sim.addToolAction(leekId, toolId, currentCellId);
  push(ret, sim);
  return sim;
}

/**
 * priorite d utilisation des weapons (pour setWeapon)
 * TODO: on peut ajouter des condition en fonction des caracteristique du poireau en face
 * 1 - WEAPON_SHOTGUN
 * 2 - WEAPON_NEUTRINO
 * 3 - WEAPON_MAGNUM
 * 4 - WEAPON_MACHINE_GUN
 * 5 - WEAPON_PISTOL
 **/
function WeaponsConditions(Map<integer,Tool> weapons) => Array<integer> {
  Array<integer> ret = [];
  if(mapContainsKey(weapons, WEAPON_SHOTGUN)) push(ret, WEAPON_SHOTGUN);
  if(mapContainsKey(weapons, WEAPON_NEUTRINO)) push(ret, WEAPON_NEUTRINO);
  if(mapContainsKey(weapons, WEAPON_MAGNUM)) push(ret, WEAPON_MAGNUM);
  if(mapContainsKey(weapons, WEAPON_MACHINE_GUN)) push(ret, WEAPON_MACHINE_GUN);
  if(mapContainsKey(weapons, WEAPON_PISTOL)) push(ret, WEAPON_PISTOL);
  return ret;
}

