/****************************************************************************
 * BasicStrategyTools
 ****************************************************************************/
class BasicStrategyTools extends Objects {

  /**
   * MPConditionsAddSim
   * macro pour MPConditions 
   **/
  static Simulation MPConditionsAddSim(Array<Simulation> ret, Simulation sim, LeekRound owner, integer toolId) {
    sim = new Simulation(sim);
    sim.addToolAction(toolId, owner.currentCellId);
    push(ret, sim);
    return sim;
  }

  /**
   * parcour
   * encapsulation de leekRound.parcour
   **/
  static Map<integer,MoveCell> parcour(LeekRound leekRound, string minMax, Array<Simulation> MPToolList, integer maxRemainingMP) {
	integer leekId = leekRound.id;
	Map<integer,integer> cellList = leekRound.parcour(leekRound.currentCell.cell, maxRemainingMP);
    Array<Array<Simulation>> simulations = []; // equivalent a une map<remainingMP,Object>
	Map<integer,MoveCell> moveCells = [:];
	for(integer cellId : integer remainingMP in cellList) 
	  moveCells[cellId] = new MoveCell(cellId, leekRound, MPToolList, remainingMP, maxRemainingMP-remainingMP);
	return moveCells;
  }
	
  /**
   * colorize
   * on decompose en different cas (couleur) et on calcul les degat
   **/
  static void colorize(Map<integer,MoveCell> myMoveCells, Map<integer,MoveCell> myMoveCellsNeutral,
				       Map<integer,MoveCell> myMoveCellsNeutralExtend, Map<integer,MoveCell> myMoveCellsBad,
				       Map<integer,MoveCell> myMoveCellsGood, Map<integer,MoveCell> myMoveCellsGoodExtend, 
				       Map<integer,MoveCell> myMoveCellsAnnihilation, 
					   Map<integer,MoveCell> myMoveCellsAnnihilationExtend) {
	  
	for(MoveCell mc in myMoveCells) {
	  if(count(mc.targetCells) == 0) {
	    if(mapSize(mc.enemyTools) == 0) {
	      if(count(mc.simulations[0].actions) > 0) myMoveCellsNeutralExtend[mc.id] = mc; 
		  else myMoveCellsNeutral[mc.id] = mc;
		} else {
		  myMoveCellsBad[mc.id] = mc;
		}
      } else {
		if(mapSize(mc.enemyTools) == 0) {
		  if(count(mc.simulations[0].actions) > 0) myMoveCellsGoodExtend[mc.id] = mc; 
		  else myMoveCellsGood[mc.id] = mc;
		  mc.computeEscape(myMoveCells);
	      mc.computeScore();
		} else {
		  mc.computeEscape(myMoveCells);
	      mc.computeScore();
		  if(count(mc.goodEscapes) > 0) {
	        if(count(((mc.goodEscapes[0].simulations as Array<Object>)[0].simulation as Simulation).actions) > 0) myMoveCellsGoodExtend[mc.id] = mc; 
		    else myMoveCellsGood[mc.id] = mc;
	      } else {
			if(count(mc.simulations[0].actions) > 0) 
			  myMoveCellsAnnihilationExtend[mc.id] = mc; 
		    else myMoveCellsAnnihilation[mc.id] = mc;
		  }
		}
      }
	}
	if(mapSize(myMoveCellsNeutralExtend) == 0 && mapSize(myMoveCellsNeutral) == 0 &&
	   mapSize(myMoveCellsGoodExtend) == 0 && mapSize(myMoveCellsGood) == 0 &&
	   mapSize(myMoveCellsAnnihilationExtend) == 0 && mapSize(myMoveCellsAnnihilation) == 0) {
      for(MoveCell mc in myMoveCellsBad) mc.computeScore();
	}
	  
  }
  	
  /**
   * moveToCellPassBy
   * s approche de cellId en s arretant uniquement sur une des cases de cellList
   * ou au pire sur cellList2
   * @return new currentCellId
   **/
  static integer moveToCellPassBy(integer cellId, Map<integer,MoveCell> cellList, Map<integer,MoveCell> cellList2) {
	if(mapContainsKey(cellList, cellId)) return cellList[cellId]!.moveToCell();
	Array<integer> path = getPath(cellId,Board.currentRound.meRound.currentCellId)!;
	for(integer cell in path) {
	  if(mapContainsKey(cellList, cell)) return cellList[cell]!.moveToCell();
	}
	for(integer cell in path) {
	  if(mapContainsKey(cellList2, cell)) return cellList2[cell]!.moveToCell();
	}
  }

  /**
   * moveAwayFromCellPassBy
   * s eloigne de cellId en s arretant uniquement sur une des cases de cellList ou au pire de cellList2
   **/
  static integer moveAwayFromCellPassBy(integer cellId, Map<any,MoveCell>cellList, Map<any,MoveCell>cellList2 = [:]){
    integer distance = 0;
	MoveCell|null ret = null;
    for(MoveCell cell in cellList) {
	  integer dist = cell.cell.interCellInfo[cellId].range;
      if(dist > distance) {
	    distance = dist;
		ret = cell;
	  }
	}
	if(ret == null) {
	  for(MoveCell cell in cellList2) {
	    integer dist = cell.cell.interCellInfo[cellId].range;
        if(dist > distance) {
	      distance = dist;
		  ret = cell;
	    }
	  }
	}
    if(ret != null) return ret!.moveToCell();
	return Board.currentRound.meRound.currentCellId;
  }
  
  /**
   * addWeapon
   **/
  static integer addWeapon(integer weaponId, Map<integer,Tool> toolsInfo, Map<integer, any> toolsList, 
						   integer targetCell, integer minTP, Object result, Simulation sim, 
						   LeekRound shooter) {
    if(mapContainsKey(toolsList, weaponId)) {
	  while(minTP >= toolsInfo[weaponId]!.cost) {
	  	Object ret = sim.addToolAction(weaponId, targetCell);
		result.minEffect += ret.minEffect;
        result.maxEffect += ret.maxEffect;
        result.midEffect += ret.midEffect;
		minTP = shooter.minTP;
	  }
	}
	return minTP;
  }

  /**
   * addChip
   **/
  static integer addChip(integer weaponId, Map<integer,Tool> toolsInfo, Map<integer, any> toolsList, 
						   integer targetCell, integer minTP, Object result, Simulation sim, 
						   LeekRound shooter) {
    if(mapContainsKey(toolsList, weaponId)) {
	  while(minTP >= toolsInfo[weaponId]!.cost && toolsInfo[weaponId]!.cooldown == 0) {
	  	Object ret = sim.addToolAction(weaponId, targetCell);
		result.minEffect += ret.minEffect;
        result.maxEffect += ret.maxEffect;
        result.midEffect += ret.midEffect;
		minTP = shooter.minTP;
	  }
	}
	return minTP;
  }
	
}