include("action");
include("simulation");
include("movecell");
include("basicstrategytools");

/****************************************************************************
 * BasicStrategy
 ****************************************************************************/
class BasicStrategy extends Strategy {
  
  static Me me;
  static integer myId;
  static integer enemyId;
  static Round currentRound;
  static MeRound meRound;
  static EnemyRound enemyRound;
  static integer myCurrentCellId;
  static integer enemyCurrentCellId;
  static Enemy enemy;          
  static integer myMaxMP;
  static integer enemyMaxMP;
  static boolean lowLife = false;
  static string myState = "center";
  static string STATE_UNKNOWN = "unknown";
  static string STATE_ESCAPE = "escape";
  static string STATE_APPROACH = "approach";
  static string STATE_ATTACK = "attack";
  static string STATE_CENTER = "center";
  static string myStrategy = "unknown";
  static string STRATEGY_UNKNOWN = "unknown";
  static string STRATEGY_HIDDEN = "hidden";
  static string STRATEGY_LONG_RANGE = "long_range";
  static string STRATEGY_SHORT_RANGE = "short_range";
  static string STRATEGY_MELEE = "melee"; // not used
  
  
  /**
   * isValide
   *
   * refuse les match avec AOE, en groupe, ou avec bulb
   **/
  static boolean isValide() {
    if(count(Board.enemies) > 1) return false;
    enemy = Board.enemies[0];
    return isEmpty(enemy.categoryBulb);
  }
  
  /**
   * apply
   **/
  boolean apply() {
	  
    me = Board.me;
	myId = me.id;
	enemyId = enemy.id;
    currentRound = Board.currentRound;
    meRound = currentRound.meRound;
    enemyRound = currentRound.enemiesRound[0];
	myCurrentCellId = meRound.currentCellId;
	enemyCurrentCellId = enemyRound.currentCellId;
    
	GameDebug.addOperation(BASIC_STRATEGY_DEBUG,"init");
	GameDebug.add(BASIC_STRATEGY_DEBUG,Board.maxAOERange,"maxAOERange");
	  
	if(gFirstRound) setStart();
	else lowLife = ((meRound.maxLife/meRound.maxTotalLife) < (enemyRound.maxLife/enemyRound.maxTotalLife));
	  
	GameDebug.add(BASIC_STRATEGY_DEBUG,myStrategy,"myStrategy");
	GameDebug.add(BASIC_STRATEGY_DEBUG,enemyRound.state,"enemyState");
	  
	//
	// phase 1 : on determine les mouvements possibles de mon poireau et du poireau adverse
	//
	Array<Simulation> MPToolList = MPConditions(meRound);
	myMaxMP = 0;
	for(Simulation sim in MPToolList) myMaxMP = max(myMaxMP, sim.roundObj.leeksRound[myId]!.minMP);
	Map<integer,MoveCell> myMoveCells = BasicStrategyTools.parcour(meRound, "minMP", MPToolList, myMaxMP);
	MPToolList = MPConditions(enemyRound);
	enemyMaxMP = 0;
	for(Simulation sim in MPToolList) enemyMaxMP = max(enemyMaxMP, sim.roundObj.leeksRound[enemyId]!.maxMP);
	Map<integer,MoveCell> enemyMoveCells = BasicStrategyTools.parcour(enemyRound, "maxMP", MPToolList, enemyMaxMP);
	  
	if(BASIC_STRATEGY_DEBUG) {
	  GameDebug.add(true, "avalaible simulations:");
	  for(integer index : Simulation sim in myMoveCells[myCurrentCellId]!.simulations)
	    GameDebug.add(true, sim.actions,"sim #"+ index);
	}
	  
	//
	// phase 2 : on determine les tire que je peux faire
	// phase 2.1: on determine pour chaque arme les relativeCell possible
	//
	Array<Tool> tools = [];
	for(ToolRound toolR in meRound.categoryDamage) push(tools,toolR.tool);
	Map<integer, RelativeCell> enemyRelativeCells = enemyRound.currentCell.cell.getRelativeCells(tools);
	  
	if(BASIC_STRATEGY_DEBUG) {
	  for(RelativeCell mc in enemyRelativeCells) {
	    mark(mc.id,COLOR_PINK,1);
		markText(mc.id,mapSize(mc.toolsList),0,1);
	  }
    }
	
	//
	// phase 2.2: pour chaque movecell on regarde si on peut atteindre une relativecell 
	//
	for(MoveCell myMoveCell in myMoveCells) myMoveCell.canIUseWeapons(enemyRelativeCells);

	//
	// phase 3: on determine les tires que l ennemi pourra faire
	//
	tools = [];
	for(ToolRound toolR in enemyRound.categoryDamage) push(tools,toolR.tool);
	for(MoveCell myMoveCell in myMoveCells) myMoveCell.canEnemyUseWeapons(enemyRound, enemyMoveCells, tools);
	
	//
	// phase 4: on decompose en different cas (couleur) et on calcul les degat
	//
	Map<integer,MoveCell> myMoveCellsNeutral = [:]; // il me touche pas je le touche pas
	Map<integer,MoveCell> myMoveCellsNeutralExtend = [:]; // il me touche pas je le touche pas
	Map<integer,MoveCell> myMoveCellsBad = [:]; // il me touche, je le touche pas
	Map<integer,MoveCell> myMoveCellsGood = [:]; // je le touche, il me touche pas
	Map<integer,MoveCell> myMoveCellsGoodExtend = [:]; // je le touche, il me touche pas
	Map<integer,MoveCell> myMoveCellsAnnihilation = [:]; // on se touche tous les 2
	Map<integer,MoveCell> myMoveCellsAnnihilationExtend = [:]; // on se touche tous les 2
	BasicStrategyTools.colorize(myMoveCells, myMoveCellsNeutral, myMoveCellsNeutralExtend, myMoveCellsBad,
				         myMoveCellsGood, myMoveCellsGoodExtend, myMoveCellsAnnihilation, myMoveCellsAnnihilationExtend);
	GameDebug.add(BASIC_STRATEGY_DEBUG,myState,"myState");
	  
	if(BASIC_STRATEGY_DEBUG) {
	  for(MoveCell mc in myMoveCellsNeutral) {
	    mark(mc.id,COLOR_BLUE,1);
		markText(mc.id,count(mc.simulations));
	  }
	  for(MoveCell mc in myMoveCellsNeutralExtend) {
	    mark(mc.id,COLOR_CYAN,1);
		markText(mc.id,count(mc.simulations));
	  }
	  for(MoveCell mc in myMoveCellsBad) {
	    mark(mc.id,COLOR_RED,1);
		markText(mc.id,count(mc.simulations));
	  }
	  for(MoveCell mc in myMoveCellsGood) {
	    mark(mc.id,COLOR_GREEN,1);
		markText(mc.id,count(mc.simulations));
	  }
	  for(MoveCell mc in myMoveCellsGoodExtend) {
	    mark(mc.id,COLOR_LIGHT_GREEN,1);
		markText(mc.id,count(mc.simulations));
	  }
	  for(MoveCell mc in myMoveCellsAnnihilation) {
	    mark(mc.id,COLOR_YELLOW,1);
		markText(mc.id,count(mc.simulations));
	  }
	  for(MoveCell mc in myMoveCellsAnnihilationExtend) {
	    mark(mc.id,COLOR_ORANGE,1);
		markText(mc.id,count(mc.simulations));
	  }
    }
	  
	// ===> a ce point j ai des movecell pour chaque case vers laquelle je peux aller, contenant : 
	// - LES simulationS de chip de MP qui doivent etre utiliser pour y aller 
	//   (y compris la simulation vide quand elle est utilisable)
	// - la liste des relativecell que je peux toucher avec, les armes utilisable sur cette relativeCell, 
	//   le poireau que je touche (pas de gestion multi target), et l AOE
	// - la liste des tools enemy qui peuvent me toucher sur cette moveCell et l AOE correspondant
	// ===> les moveCells sont trier par couleur
	 
	//
	// phase 5: je repartie vers la bonne strategie
	//
    if(mapSize(myMoveCellsGood) > 0 || mapSize(myMoveCellsGoodExtend) > 0) 
		return good(myMoveCellsGood, myMoveCellsGoodExtend, myMoveCellsAnnihilation, myMoveCellsAnnihilationExtend);
	if(mapSize(myMoveCellsNeutral) > 0 || mapSize(myMoveCellsNeutralExtend) > 0) 
		return neutral(myMoveCellsNeutral, myMoveCellsNeutralExtend, myMoveCellsAnnihilation,
					   myMoveCellsAnnihilationExtend);
	if(mapSize(myMoveCellsAnnihilation) > 0 || mapSize(myMoveCellsAnnihilationExtend) > 0) 
		return good(myMoveCellsGood, myMoveCellsGoodExtend, myMoveCellsAnnihilation, myMoveCellsAnnihilationExtend);
	return bad(myMoveCellsBad);
	
  }

// ----------------------------------------------- strategy ----------------------------------------------------

  /**
   * heal
   * TODO: remplacer les constantes
   **/
  static void heal() {
    if(meRound.minTotalLife - meRound.maxLife > 46) { // 46 = max CHIP_CURE
      useChip(CHIP_STRETCHING) // 3
	  useChip(CHIP_CURE); // 4
	  meRound.update();  
	}
	if(meRound.minTotalLife - meRound.maxLife > 28) { // 28 = max CHIP_BANDAGE
      useChip(CHIP_STRETCHING) // 3
	  useChip(CHIP_BANDAGE); // 2
	  meRound.update();  
	}
  }
  
 /**
  * setStrategy
  * choix de l arme a degainer au depart et de la strategie global
  * 1 - WEAPON_SHOTGUN
  * 2 - WEAPON_NEUTRINO
  * 3 - WEAPON_MAGNUM
  * 4 - WEAPON_MACHINE_GUN
  * 5 - WEAPON_PISTOL
  **/
  static void setStart() {
    if(me.maxAOERange > enemy.maxAOERange) myStrategy = STRATEGY_LONG_RANGE;
	else if(!me.needLos && enemy.needLos) myStrategy = STRATEGY_HIDDEN;
	else myStrategy = STRATEGY_SHORT_RANGE;
	Map<integer,Tool> weapons = me.tools;
    if(mapContainsKey(weapons, WEAPON_SHOTGUN)) meRound.setWeaponRound(WEAPON_SHOTGUN);
    else if(mapContainsKey(weapons, WEAPON_NEUTRINO)) meRound.setWeaponRound(WEAPON_NEUTRINO);
    else if(mapContainsKey(weapons, WEAPON_MAGNUM)) meRound.setWeaponRound(WEAPON_MAGNUM);
    else if(mapContainsKey(weapons, WEAPON_MACHINE_GUN)) meRound.setWeaponRound(WEAPON_MACHINE_GUN);
    else if(mapContainsKey(weapons, WEAPON_PISTOL)) meRound.setWeaponRound(WEAPON_PISTOL);
    else {
	  if(count(me.weapons) > 0) {
	    meRound.setWeaponRound(me.weapons[0].id);
	    debugC("BasicStrategy=>neutral=>aucune arme connu", COLOR_RED);
	    debugC(Board.me.tools, COLOR_RED);
	  } // else j ai pas d arme
    }
  }

  /**
   * good
   **/
  static boolean good(Map<integer,MoveCell> myGoods, Map<integer,MoveCell> myGoodsExtend,
					  Map<integer,MoveCell> myAnnihilations, Map<integer,MoveCell> myAnnihilationExtend) {
	// TODO: il faut determiner si il est interessant d utiliser qu en meme les buff de MP si ca nous donne un avantage au tour suivant
	debugC("BasicStrategy=>good=>calcul des degat et choix de la moveCell pour l attaque et penser a s echapper si c est une annihilation",COLOR_RED);  
	return true;
  }

  /**
   * neutral
   **/
  static boolean neutral(Map<integer,MoveCell> myMoveCellsNeutral, Map<integer,MoveCell> myMoveCellsNeutralExtend,
						 Map<integer,MoveCell> myMoveCellsAnnihilation, 
						 Map<integer,MoveCell> myMoveCellsAnnihilationExtend) {
	// je suis blaisse
	// il s eloigne
	boolean jaiUneAnnihilationInteressante = BasicStrategyTools.getScore(myMoveCellsAnnihilation,
																		 myMoveCellsAnnihilationExtend) > 0;
	boolean jeSuisLoin = (mapSize(myMoveCellsBad) == 0 && mapSize(myMoveCellsAnnihilation) == 0 &&
	  meRound.currentCell.cell.interCellInfo[enemyRound.currentCell.cell.getTowardCellId(myCurrentCellId, enemyMaxMP)].range > Board.maxAOERange)  
	if(myState == STATE_CENTER) {
	  integer centerId = meRound.getRelativeCenter();
	  integer oldCellId = BasicStrategy.myCurrentCellId;
	  myCurrentCellId = BasicStrategyTools.moveToCellPassBy(centerId, myMoveCellsNeutral, myMoveCellsNeutralExtend);
	  if(myCurrentCellId == centerId || oldCellId == myCurrentCellId) myState = STATE_APPROACH; // je suis arrive au centre ou je ne peux pas avancer plus
	} else if(myState == STATE_ESCAPE) {
	  myCurrentCellId = BasicStrategyTools.moveAwayFromCellPassBy(enemyCurrentCellId, myMoveCellsNeutral, myMoveCellsNeutralExtend);
	  heal();
	  myState = STATE_CENTER;
	  return true;
    } else { // STATE_APPROACH
	  integer oldCellId = BasicStrategy.myCurrentCellId;
	  myCurrentCellId = BasicStrategyTools.moveToCellPassBy(enemyCurrentCellId, myMoveCellsNeutral);
	  if(oldCellId == myCurrentCellId) {
	    myState = STATE_ATTACK; // je ne peux pas avancer plus
		neutral(myMoveCellsNeutral, myMoveCellsNeutralExtend, myMoveCellsBad, 
				myMoveCellsAnnihilation, myMoveCellsAnnihilationExtend);
	  }
	}
	if(mapSize(myMoveCellsAnnihilation) > 0) {
	  integer maxScore = -100000;
	  Array<MoveCell> bestMc = [];
	  for(MoveCell mc in myMoveCellsAnnihilation) {
		integer s = mc.computeScore();
		if(s > maxScore) {
		  bestMc = [mc];
		  maxScore = s;
		} else if(s == maxScore) {
		  push(bestMc, mc);
		} 
	  }
	  if(maxScore > 0) {
	    debugC("BasicStrategy=>neutral=>trouver la meilleure soluce de la liste en fonction de la strategy long/short...",COLOR_BLUE);
		bestMc[0].execute();
	  }
	}
    if(mapSize(myMoveCellsBad) > 0 || mapSize(myMoveCellsAnnihilation) > 0 ||
	  meRound.currentCell.cell.interCellInfo[enemyRound.currentCell.cell.getTowardCellId(myCurrentCellId, enemyMaxMP)].range < Board.maxAOERange) {
	  if(myStrategy == STRATEGY_LONG_RANGE) {
		useChip(CHIP_STRETCHING) // 3
	    useChip(CHIP_PROTEIN); // 3
		useChip(CHIP_MOTIVATION) // 4
		useChip(CHIP_HELMET); // 3
		useChip(CHIP_WALL); // 3
	  } else if(myStrategy == STRATEGY_SHORT_RANGE) {
		useChip(CHIP_STRETCHING) // 3
		useChip(CHIP_MOTIVATION) // 4
		useChip(CHIP_HELMET); // 3
		useChip(CHIP_WALL); // 3
		useChip(CHIP_PROTEIN); // 3
	  } else if(myStrategy == STRATEGY_HIDDEN) {
		useChip(CHIP_STRETCHING) // 3
		useChip(CHIP_LEATHER_BOOTS) // 3
		useChip(CHIP_HELMET); // 3
		useChip(CHIP_WALL); // 3
		moveTowardCell(enemyCurrentCellId);
	  } else { // STRATEGY_MELEE
	  }
	}
	return true;
  }
	
  /**
   * bad
   **/
  static boolean bad(Map<integer,MoveCell> moveCellsList) {
    debugC("BasicStrategy=>bad=>on choisi la moins pire des bads",COLOR_RED); 
	// TODO: on mets les protection, les heal et les preservatif
	return true;
  }
	
  /**
   * condition d utilisation des chips lors de la phase de prediction des mouvements
   * une simuation par combinaison de chip
   * 0- pas de chip
   * 1- CHIP_LEATHER_BOOTS
   * TODO: chip de saut
   **/
  static Array<Simulation> MPConditions(LeekRound owner) {
    Simulation sim = new Simulation(owner);
    Array<Simulation> ret = [sim]; // cas sans chip
	
    if(mapContainsKey(owner.toolsRound, CHIP_LEATHER_BOOTS))
	  BasicStrategyTools.MPConditionsAddSim(ret, sim, owner, CHIP_LEATHER_BOOTS); // CHIP_LEATHER_BOOTS
	  
    return ret;
  }

  /**
   * computeAttack
   * 1- WEAPON_SHOTGUN
   * 2- WEAPON_NEUTRINO
   * 3- CHIP_ROCK
   * 4- CHIP_FLASH
   * 5- WEAPON_MAGNUM
   * 5.1- WEAPON_MACHINE_GUN
   * 6- CHIP_ICE
   * 6.1- WEAPON_PISTOL
   * 7- CHIP_PEBBLE
   * 8- CHIP_SPARK
   * 9- CHIP_SHOCK
   * TODO: enlever les constante
   **/
  static integer computeAttack(Simulation sim, RelativeCell rel, integer ownerId) {
	Map<integer, Tool> toolsList = rel.toolsList;
	integer targetCell = rel.id;
	LeekRound shooter = sim.roundObj.leeksRound[ownerId]!;
	integer minTP = shooter.minTP;
	integer|null currentWeapon = shooter.weaponId;
	Map<integer,Tool> toolsInfo = Board.leeks[ownerId]!.tools;
	Object result = {minEffect:0,maxEffect:0,midEffect:0};
	// TODO: add une action SetWeapon 
	// TODO: --------------------------------------- ici --------------------------------------------
	minTP = BasicStrategyTools.addWeapon(WEAPON_SHOTGUN, toolsInfo, toolsList, targetCell, minTP, result, sim, shooter);
	
  }

}

