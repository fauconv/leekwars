include("basicstrategyrules");
include("movecell");

/****************************************************************************
 * BasicStrategy
 ****************************************************************************/
class BasicStrategy extends Strategy {
  
  static Enemy enemy;          
  static integer enemyId;
  static MeRound meRound;       // MeRound
  static EnemyRound enemyRound;    // EnemyRound
  static Round currentRound;  // Round
  static Array<Simulation> mySoluces = []; // l id des soluce correspond a l id de l index du tableau comme si c etait une map
  
  /**
   * isValide
   *
   * refuse les match avec AOE, en groupe, ou avec bulb
   **/
  static boolean isValide() {
    if(count(Board.enemies) > 1) return false;
    enemy = Board.enemies[0];
    enemyId = enemy.id;
    return isEmpty(enemy.categoryBulb);
  }
  
  /**
   * apply
   **/
  void apply() {
    currentRound = Board.currentRound;
    meRound = currentRound.meRound;
    enemyRound = currentRound.enemiesRound[0];
    
	GameDebug.addOperation(true,"init");
	GameDebug.add(true,Board.maxAOERange,"maxAOERange");
	  
	//
	// first round
	//
    if(gFirstRound) {
      moveTowardCell(meRound.getRelativeCenter().id);
	  if(count(meRound.weaponsRound) > 0) setWeapon(meRound.weaponsRound[0].id)
      return;
    }
	  
	//
	// other rounds
	//
	
	//
	// phase 1 : on determine les mouvements possibles de mon poireau
	// phase 1.1 : on determine quel chip utilisable pour se mouvoir => simulations
	//
	Array<Simulation> myMPToolList = MPConditions(meRound);
	//GameDebug.add(BASIC_STRATEGY_DEBUG, myMPToolList,"",1,[], [], [], "string");
	  
	//
	// phase 1.2 : on calcul chaque mouvement possible et chaque simulation impliquee
	// certaine simulation permettent d aller plus loin grace au chips de buff MP
	//
	Map<integer,MoveCell> myMoveCells = parcour(meRound.currentCell, myMPToolList, meRound.id)
	
	//
	// phase 2 : on determine les tire que je peux faire
	// phase 2.1: on determine pour chaque arme les relativeCell possible
	//
	//GameDebug.add(BASIC_STRATEGY_DEBUG,meRound.leek.categoryDamage,"liste de mes armes",1,[],[],[],"string");
	Array<Tool> tools = [];
	for(ToolRound toolR in meRound.categoryDamage) push(tools,toolR.tool);
	Map<integer, RelativeCell> enemyRelativeCells = enemyRound.currentCell.cell.getRelativeCells(tools);
	if(BASIC_STRATEGY_DEBUG) {
	  for(RelativeCell mc in enemyRelativeCells) {
	    mark(mc.id,COLOR_PINK,1);
		markText(mc.id,count(mc.toolsList),0,1);
	  }
    }
	
	//
	// phase 2.2: pour chaque movecell on regarde si on peut atteindre une relative cell pour chaque arme de la relativecell
	// canUseWeaponOnCell ne convient pas car il ne prend pas en compte les moveCell
	//
    Map<integer,Map<string,Map<integer,RelativeCell>>> enemyRelativeCellsCache = [:] // [relativeCellId][hashToolList][targetCell] = RelativeCell
	                                                                            // en visant relativeCellId avec cette liste d arme hashToolList 
	                                                                            // on peut atteindre la/les targetCell ayant chacune son AOE
	for(MoveCell myMoveCell in myMoveCells) {
	  for(RelativeCell enemyRelativeCell in enemyRelativeCells) {
		InterCellInfo interCellInfo = myMoveCell.cell.interCellInfo[enemyRelativeCell.id];
        integer range = interCellInfo.range;
		if(range > Board.maxAOERange) continue;
        boolean isInsight = interCellInfo.isInsight && currentRound.lineOfSight(interCellInfo);
        boolean isDiag = interCellInfo.isDiag;
        boolean isInLine = interCellInfo.isInline;		
		Array<Tool> toolsList = [];
	    for(Tool tool in enemyRelativeCell.toolsList) {
          integer launch = tool.launchType;
          if(range > tool.maxRange || range < tool.minRange || tool.needLos && !isInsight || 
             launch == LAUNCH_TYPE_LINE && !isInLine || launch == LAUNCH_TYPE_DIAGONAL && !isDiag || 
             launch == LAUNCH_TYPE_STAR && !isDiag && !isInLine || launch == LAUNCH_TYPE_STAR_INVERTED && (isDiag || isInLine)) continue
		  push(toolsList,tool);
		}
        string hash = "";
		for(Tool tool in toolsList) {
		  hash += tool.id+".";
		}
		integer id = enemyRelativeCell.id;
		integer targetCell = enemyRelativeCell.targetCell;
		if(!mapContainsKey(enemyRelativeCellsCache, id)) {
		   enemyRelativeCellsCache[id] = [hash:[targetCell:new RelativeCell(id, enemyRelativeCell.AOE,targetCell,toolsList)]];
		} else if(!mapContainsKey(enemyRelativeCellsCache[id]!, hash)) {
		   enemyRelativeCellsCache[id]![hash] = [targetCell:new RelativeCell(id, enemyRelativeCell.AOE,targetCell,toolsList)];
		} else if(!mapContainsKey(enemyRelativeCellsCache[id]![hash]!, targetCell)) {
		   enemyRelativeCellsCache[id]![hash]![targetCell] = new RelativeCell(id, enemyRelativeCell.AOE,targetCell,toolsList);
		}  
		push(myMoveCell.targetCells,enemyRelativeCellsCache[id]![hash]![targetCell]!);
	  }
	}
	  
	// ===> a ce point j ai des movecell pour chaque case vers laquelle je peux aller 
	//      contenant LES simulationS de chip de MP qui doivent etre utiliser pour y aller (y compris la simulation vide quand elle est utilisable)
	//     pour chaque movecell j ai egalement la liste des relativecell que je peux toucher avec les armes utilisable sur cette relativeCell
	// ===> la relativecell contient UN poireau cible (ne gere pas le multi target) avec l AOE correspondant.
	// ===> les enemyRelativeCells contienne la liste des arme qui doivent etre utilise pour cette relativecell pour atteindre le leek cible
	//      par contre les relativeCell contenu dans les movecell contienne les armes qui peuvent etre utilise a partir de ce movecell sur la 
	//      relativecell pour atteindre le leek cible
	  
	//
	// phase 3: on determine les mouvements possibles du poireau ennemi (identique a phase 1)
	//
	Array<Simulation> enemyMPToolList = MPConditions(enemyRound);
	Map<integer,MoveCell> enemyMoveCells = parcour(enemyRound.currentCell, enemyMPToolList, enemyRound.id);
	  
	//
	// phase 4: on determine les tires que l ennemi pourra faire
	// pour chaqu une de mes moveCell je regarde si il peut me tirer dessus depuis au moins une de ces moveCell
	// je dois calculer les relativecell de chaqu une de mes moveCells 
	// comment je determine quel est sa meilleure moveCell pour ma movecell ? je cumule ses armes dans ma moveCell ?
	//
	tools = [];
	for(ToolRound toolR in enemyRound.categoryDamage) push(tools,toolR.tool);
	for(MoveCell myMoveCell in myMoveCells) {
	  Map<integer, RelativeCell> myRelativeCells = myMoveCell.cell.getRelativeCells(tools);
	  Map<real,Map<integer,Tool>> enemyTools = myMoveCell.enemyTools;
	  for(RelativeCell myRelativeCell in myRelativeCells) {
		for(MoveCell enemyMoveCell in enemyMoveCells) {
	      InterCellInfo interCellInfo = enemyMoveCell.cell.interCellInfo[myRelativeCell.id];
          integer range = interCellInfo.range;
		  if(range > Board.maxAOERange) continue;
          boolean isInsight = interCellInfo.isInsight && currentRound.lineOfSight(interCellInfo);
          boolean isDiag = interCellInfo.isDiag;
          boolean isInLine = interCellInfo.isInline;		
	      for(Tool tool in myRelativeCell.toolsList) {
            integer launch = tool.launchType;
            if(range > tool.maxRange || range < tool.minRange || tool.needLos && !isInsight || 
               launch == LAUNCH_TYPE_LINE && !isInLine || launch == LAUNCH_TYPE_DIAGONAL && !isDiag || 
               launch == LAUNCH_TYPE_STAR && !isDiag && !isInLine || launch == LAUNCH_TYPE_STAR_INVERTED && (isDiag || isInLine)) continue
		    if(!mapContainsKey(enemyTools, myRelativeCell.AOE)) enemyTools[myRelativeCell.AOE] = [tool.id:tool];
			else enemyTools[myRelativeCell.AOE]![tool.id] = tool; // si il existe deja on l ecrase c est pas grave
		  }
		}
	  }
	}
	 
	Object myColoredMoveCells {
	  neutral:[], // il me touche pas je le touche pas
	  bad:[], // il me touche, je le touche pas
	  good:[], // je le touche, il me touche pas
	  annihilation:[] // on se touche tous les 2
    }
	for(MoveCell mc in myMoveCells) {
	  if(count(mc.targetCells) == 0) {
	    if(mapSize(mc.enemyTools) == 0) {
		  push(myColoredMoveCells.neutral as Array, mc);
		  mark(mc.id,COLOR_BLUE,1); // je ne peux pas toucher, il ne peut pas me toucher
		} else {
		  push(myColoredMoveCells.bad as Array, mc);
		  mark(mc.id,COLOR_RED,1); // je ne peux pas toucher, il peut me toucher
		}
      } else {
		if(mapSize(mc.enemyTools) == 0) {
		  push(myColoredMoveCells.good as Array, mc);
		  mark(mc.id,COLOR_GREEN,1); // je peux le toucher, il peut pas me toucher
		} else {
		  push(myColoredMoveCells.annihilation as Array, mc);
		  mark(mc.id,COLOR_YELLOW,1); // on peut se toucher tous les 2
		}
      }
	}
	
	// ===> a ce point j ai des movecell pour chaque case vers laquelle je peux aller, contenant : 
	//      - LES simulationS de chip de MP qui doivent etre utiliser pour y aller (y compris la simulation vide quand elle est utilisable)
	//      - la liste des relativecell que je peux toucher avec, les armes utilisable sur cette relativeCell, 
	//                                                            le poireau que je touche (pas de gestion multi target), et l AOE
	//      - la liste des tools enemy qui peuvent me toucher sur cette moveCell et l AOE correspondant
	// ===> les moveCells sont trier par couleur
	
	// TODO: ------------------------------- reprendre le code de la ------------------------------------------
	  
	if(count(myColoredMoveCells.good as Array) > 0) good(myColoredMoveCells.good as Array<MoveCell>);
	else if(count(myColoredMoveCells.annihilation as Array) > 0) annihilation(myColoredMoveCells.annihilation as Array<MoveCell>);
	else if(count(myColoredMoveCells.neutral as Array) > 0) neutral(myColoredMoveCells.neutral as Array<MoveCell>);
	else bad(myColoredMoveCells.bad as Array<MoveCell>);
	  
	//
	// phase 5: pour chaque moveCell je determine les moveCells de retraite
	//
	  
	//
    // phase X: pour chaque combinaison d arme, AOE, nbtarget,tp touche on determine les degat obtenu et la meilleure combi
	
	//
	// phase X : on determine les chip de soin et de protection a utiliser
	//
	
	//
	// phase X : on choisi la meilleure soluce
	//
	
  }

	
  /**
   * parcour
   * Attention: on utilise le round de la startCell comme reference pour determiner la position 
   * des poireaux
   * TODO: ajouter la gestion de la chip de saut
   **/
  Map<integer,MoveCell> parcour(CellRound startCell, Array<Simulation> simulations, integer leekId) {
	  
	integer maxRemainingMP = 0;
	Array<integer> remainingMPBySimulation = [];
	for(Simulation sim in simulations) {
	  integer mp = sim.roundObj.leeksRound[leekId]!.minMP;
	  (mp > maxRemainingMP) and (maxRemainingMP = mp);
	  push(remainingMPBySimulation, mp);
	}
	Cell voisin;
	Array<CellRound> referenceBoard = startCell.roundObj.cellsRound;
		
    Map<integer,Array<Cell>> reachableCells = [maxRemainingMP:[startCell.cell]] //reachableCells[remainingMP][] = cell
    Map<integer,MoveCell> flatReachableCells = [startCell.id:new MoveCell(startCell.cell, leekId, simulations, remainingMPBySimulation, maxRemainingMP)]
    
    for(integer i = maxRemainingMP; i > 0; i--) {
      integer futurMP = i-1
      reachableCells[futurMP] = [];
	  Array<Simulation> remainingSimulation2 = [];
	  Array<integer> remainingMPBySimulation2 = [];
	  for(integer index: integer remainingMP in remainingMPBySimulation) {
		if(remainingMP > 0) {
		  push(remainingMPBySimulation2,remainingMP-1);
		  push(remainingSimulation2, simulations[index]);
		}
	  }
	  remainingMPBySimulation = remainingMPBySimulation2;
	  simulations = remainingSimulation2;
      for(Cell cell2 in reachableCells[i]!) {
        for(string direction in LINE_DIRECTION) {
          if(!(voisin = cell2[direction] as Cell) || voisin.isWall) continue
          integer voisinId = voisin.id;
          LeekRound|null leekvoisin = referenceBoard[voisinId].leekOnCell;
          if(!mapContainsKey(flatReachableCells, voisinId) && (!leekvoisin || leekvoisin!.id == leekId)) { // dans le cas d un deuxieme appel a parcour il se peut qu on retombe sur la position initial du poireau concerne
            push(reachableCells[futurMP]!, voisin);
            flatReachableCells[voisinId] = new MoveCell(voisin, leekId, simulations, remainingMPBySimulation, futurMP);
		  }
        }
      }
    }
    return flatReachableCells
	  
  }

  /**
   * good
   **/
  void good(Array<MoveCell> moveCellsList) {
  }

  /**
   * neutral
   **/
  void neutral(Array<MoveCell> moveCellsList) {
  }

  /**
   * annihilation
   **/
  void annihilation(Array<MoveCell> moveCellsList) {
  }

  /**
   * bad
   **/
  void bad(Array<MoveCell> moveCellsList) {
  }
}

